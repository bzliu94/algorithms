from ...tree.bbst.SplayTree import *

from ...tree.Entry import *

from BalancedIntervalTreeNode import *

from Interval import *

from IntervalEntry import *

# maintain for each node a max field 
# for storing max value of a right endpoint 
# of an interval in the subtree 
# rooted at the node

# use as key the interval

# internally, use left endpoint as key

class BalancedIntervalTree(SplayTree):

  def __init__(self, key_transform = lambda x: x.getLeftEndpoint(), comparator = comp):

    # key internal representation is an interval object

    # transformed key is interval left endpoint

    # key_transform = lambda x: x.getLeftEndpoint()

    SplayTree.__init__(self, key_transform, comparator)

  # entries are (interval, value) pairs

  @staticmethod

  def construct(entries):

    tree = BalancedIntervalTree()

    for entry in entries:

      key, value = entry

      tree.intervalInsert(key, value)

    return tree
    
  def _expandExternal(self, external_node, left_entry, right_entry):
  
    self._expandExternalHelper(external_node, left_entry, right_entry, BalancedIntervalTreeNode)
    
  def addRoot(self, entry):

    self._addRootHelper(entry, BalancedIntervalTreeNode)

  # return an entry
  
  def _insertIntroduceEntry(self, key, value, ins_node):
  
    return self._insertAtExternal(ins_node, IntervalEntry(key, value))

  # return an (entry, node) pair
    
  def _insertWithUntransformedKeyForTree(self, untransformed_key, value):

    # return self._insertHelper(untransformed_key, value, self._treeSearchWithUntransformedKey)

    return self.insert(untransformed_key, value)

  # remove an entry with matching (transformed) key

  # note: entry provided should involve untransformed key

  # return an (entry, node) pair

  def _removeForTree(self, entry):

    # return self._removeHelper(entry, self._treeSearch)
    
    return self.remove(entry)

  """

  # return an (entry, node) pair

  def _removeForTree(self, entry_with_transformed_key):

    # return self._removeHelper(entry_with_transformed_key, self._treeSearch)
    
    return self.remove(entry_with_transformed_key)

  """

  """
    
  # return an (entry, node) pair
  
  def _removeWithUntransformedKeyForTree(self, entry_with_untransformed_key):

    # return self._removeHelper(entry_with_untransformed_key, self._treeSearchWithUntransformedKey)
    
    return self.removeWithUntransformedKey(entry_with_untransformed_key)

  """
    
  """

  # return an entry
    
  def insert(self, transformed_key, value):
  
    return (self._insertForTree(transformed_key, value))[0]

  # return an entry

  def remove(self, entry_with_transformed_key):
  
    return (self._removeForTree(entry_with_transformed_key))[0]

  """

  """

  # do not assume node is an internal node

  def _updateMaxValuesForParents(self, node):

    if node.isExternal() == True:

      return

  """

  # update max values for node and its parents

  # do not assume node is an internal node

  def _updateMaxValuesForParents(self, node):
  
    if node == self.getRoot():
    
      return

    elif node.isExternal() == True:

      self._updateMaxValuesForParents(node.getParent())

    elif node.isExternal() == False:
    
      # candidate_values = []

      tagged_candidate_nodes = []
      
      if node.hasLeftChild() == True:
      
        # candidate_values.append(node.getLeftChild().getMax())
        
        tagged_candidate_nodes.append((node.getLeftChild(), True))

      if node.hasRightChild() == True:
      
        # candidate_values.append(node.getRightChild().getMax())
        
        tagged_candidate_nodes.append((node.getRightChild(), True))

      # curr_right_endpoint = node.getElement().getKey().getRightEndpoint()

      tagged_candidate_nodes.append((node, False))

      # candidate_values.append(curr_right_endpoint)
      
      # next_max_value = max(candidate_values)

      tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes(tagged_candidate_nodes)

      entry, came_from_max_bearing_node = tagged_entry

      max_value = self._getMaxValue(entry)

      # node.setMax(next_max_value)

      self._setMaxValue(node, entry)

      self._updateMaxValuesForParents(node.getParent())

  # i is an interval and has form of an Interval object
  
  # return an (entry, node) pair

  def intervalInsert(self, i, value):

    """

    if i.getLeftEndpoint() > i.getRightEndpoint():

      print i.getLeftEndpoint(), i.getRightEndpoint()

      raise Exception("unexpected endpoints with insertion of an interval")

    """
  
    # actually insert

    entry, node = self._insertWithUntransformedKeyForTree(i, value)
    
    # take care of inserted node's max value
    
    right_endpoint = i.getRightEndpoint()
    
    # print "introduced interval's right_endpoint:", right_endpoint

    # entry = node.getElement()

    # node.setMax(right_endpoint)

    self._setMaxValue(node, entry)

    """
    
    # take care of max values

    tree_search = self._treeSearchWithUntransformedKey
    
    ins_node = self._insertRetrieveNode(i, value, tree_search)
  
    self._updateMaxValuesForParents(ins_node)
    
    """
    
    # take care of max values
    
    self._updateMaxValuesForParents(node)

    return (entry, node)

  # i is an interval and has form of an Interval object
  
  # return an (entry, node) pair

  def intervalDelete(self, i, value):

    # entry, node = self.find(i)

    # print entry.toString()

    # raise Exception("attempting to remove an interval")

    """

    interval_entries = self.findAll(i.getLeftEndpoint())

    matching_interval_entries = [x for x in interval_entries if x[0].isEqualTo(i)]

    chosen_interval_entry = matching_intervals[0]

    self.remove(IntervalEntry((chosen_interval_entry[0]).getLeftEndpoint(), value))

    """
    
    # for taking care of max values
    
    # tree_search = self._treeSearchWithUntransformedKey

    # print "interval to be removed:", i.toString(), value
    
    # w = self.removeRetrieveNode(IntervalEntry(i, value), tree_search)
    
    w = self._removeRetrieveNode(IntervalEntry(i, value))

    """

    print w.isExternal()

    print self.toString()

    """
    
    rem_node = self._removeRetrieveReplacementNode(w)
    
    rem_node_sibling = rem_node.getSibling()
    
    """

    # actually remove

    self.removeWithUntransformedKey(IntervalEntry(i, value))
    
    """
    
    # actually remove
    
    # entry, node = self._removeWithUntransformedKeyForTree(IntervalEntry(i, value))

    entry, node = self._removeForTree(IntervalEntry(i, value))
    
    # take care of max values
    
    self._updateMaxValuesForParents(rem_node_sibling)
    
    return (entry, node)

    """
    
    # actually remove
    
    entry, node = self._removeForTree(i, value)
    
    # take care of max values
    
    self._updateMaxValuesForParents(node)

    """

  # retrieve a tagged mediating entry

  # tagged_candidate_node_options is a list of two-tuples

  # each tagged candidate node option is a (candidate_node_option, is_max_bearing_node) tuple

  # candidate_node_option is either a node or None

  # is_max_bearing_node is a boolean value that describes whether node is to have its max value inspected as opposed to having the right endpoint of corresponding interval inspected

  # two types of candidate nodes: max-bearing and specific

  # choose a max-responsible entry

  # return an (entry, corresponds_to_max_bearing_node) tuple

  def getTaggedMediatingEntryGivenTaggedCandidateEntries(self, tagged_candidate_entries):

    tagged_max_bearing_node_options = [x for x in tagged_candidate_node_options if x[1] == True]

    tagged_specific_node_options = [x for x in tagged_candidate_node_options if x[1] == False]

    tagged_max_bearing_nodes = [x[0] for x in tagged_max_bearing_node_options if x[0] != None]

    tagged_specific_nodes = [x[0] for x in tagged_specific_node_options if x[0] != None]

    tagged_candidate_nodes = tagged_max_bearing_nodes + tagged_specific_nodes

    max_bearing_node_options = [x[0] for x in tagged_max_bearing_node_options]

    specific_node_options = [x[0] for x in tagged_specific_node_options]

    max_bearing_nodes = [x for x in max_bearing_node_options if x != None]

    specific_nodes = [x for x in specific_node_options if x != None]

    max_bearing_node_possible_max_value_pairs = [(x, x.getMaxValue()) for x in max_bearing_nodes]

    specific_node_possible_max_value_pairs = [(x, x.getElement().getRightEndpoint()) for x in specific_nodes]

    candidate_node_possible_max_value_pairs = max_bearing_node_possible_max_value_pairs + specific_node_possible_max_value_pairs

    possible_max_values = [x[1] for x in candidate_node_possible_max_value_pairs]

    chosen_max_value = max(possible_max_values)

    matching_candidate_node_possible_max_value_pairs = [x for x in candidate_node_possible_max_value_pairs if x[1] == chosen_max_value]

    matching_candidate_node_possible_max_value_pair = matching_candidate_node_possible_max_value_pairs[0]

    chosen_candidate_node = matching_candidate_node_possible_max_value_pair[0]

    matching_tagged_candidate_nodes = [x for x in tagged_candidate_nodes if x[0] == chosen_candidate_node]

    matching_tagged_candidate_node = matching_tagged_candidate_nodes[0]

    is_max_bearing_node = matching_tagged_candidate_node[1]

    comes_from_max_bearing_node = is_max_bearing_node

    chosen_entry = chosen_candidate_node.getElement()

    result = (chosen_entry, comes_from_max_bearing_node)

    return result

    # return matching_candidate_node_possible_max_value_pair

    # return matching_tagged_candidate_node

  @staticmethod

  def getTaggedNodesGivenTaggedNodeOptions(tagged_node_options):

    tagged_nodes = [x for x in tagged_node_options if x[0] != None]

    return tagged_nodes

  @staticmethod

  def getTaggedEntriesGivenTaggedNodeOptions(tagged_node_options):

    tagged_nodes = BalancedIntervalTree.getTaggedEntriesGIvenTaggedNodeOptions(tagged_node_options)

    tagged_entries = [((x[0]).getElement(), x[1]) for x in tagged_nodes]

    return tagged_entries

  # retrieve a scalar

  def _getMaxValue(self, node):

    return node.getMaxValue()

  # set a max value based on a tagged mediating entry

  def _setMaxValue(self, node, tagged_mediating_entry):

    mediating_entry, came_from_max_bearing_node = tagged_mediating_entry

    max_value = None

    if came_from_max_bearing_node == True:

      max_value = mediating_entry.getMaxValue()

    elif came_from_max_bearing_node == False:

      max_value = mediating_entry.getMaxValue()

    node.setMaxValue(node, max_value)

  def _zig_zig(self, x):

    # take care of max values

    y = x.getParent()

    z = y.getParent()

    if x.isLeftChild() == True:

      # left, left

      t1 = x.getLeftChild()

      t2 = x.getRightChild()

      t3 = y.getRightChild()

      t4 = z.getRightChild()
      
      """
      
      print x, y, z
      
      print t1, t2, t3, t4
      
      """

      z_tagged_candidate_node_options = [(t3, True), (t4, True), (z, False)]

      z_tagged_candidate_nodes = self.getTaggedNodesGivenTaggedNodeOptions(z_tagged_candidate_node_options)

      z_tagged_candidate_entries = self.getTaggedEntriesGivenTaggedNodes(z_tagged_candidate_nodes)

      z_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateEntries(z_tagged_candidate_entries)

      y_tagged_candidate_node_options = [(t2, True), (y, False)]

      y_tagged_candidate_nodes = self.getTaggedNodesGivenTaggedNodeOptions(y_tagged_candidate_node_options)

      

      y_tagged_candidate_entry_options = self.getTaggedEntriesGivenTaggedNodeOptions(y_tagged_candidate_node_options)

      z_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([(t3, True), (t4, True), (z, False)])

      z_entry, z_came_from_max_bearing_node = z_tagged_entry

      z_max_value = self._getMaxValue(z_entry)

      z_max_node = z_entry.getLocation()

      z_tagged_node = (z_max_node, z_came_from_max_bearing_node)

      y_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([(t2, True), z_tagged_node, (y, False)])

      y_entry, y_came_from_max_bearing_node = y_tagged_entry

      y_max_value = self._getMaxValue(y_entry)

      y_max_node = y_entry.getLocation()

      y_tagged_node = (y_max_node, y_came_from_max_bearing_node)

      x_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([(t1, True), y_tagged_node, (x, False)])

      x_entry, x_came_from_max_bearing_node = x_tagged_entry

      x_max_value = self._getMaxValue(x_entry)

      x_max_node = x_entry.getLocation()

      x_tagged_node = (x_max_node, x_came_from_max_bearing_node)

      self._setMaxValue(x, x_tagged-entry)

      self._setMaxValue(y, y_entry)

      self._setMaxValue(z, z_entry)

    else:

      # right, right

      t1 = z.getLeftChild()

      t2 = y.getLeftChild()

      t3 = x.getLeftChild()

      t4 = x.getRightChild()
      
      z_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([(t1, True), (t2, True), (z, False)])

      z_entry, z_came_from_max_bearing_node = z_tagged_entry

      z_max_value = self._getMaxValue(z_entry)

      z_max_node = z_entry.getLocation()

      z_tagged_node = (z_max_node, z_came_from_max_bearing_node)

      y_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([z_tagged_node, (t3, True), (y, False)])

      y_entry, y_came_from_max_bearing_node = y_tagged_entry

      y_max_value = self._getMaxValue(y_entry)

      y_max_node = y_entry.getLocation()

      y_tagged_node = (y_max_node, y_came_from_max_bearing_node)

      x_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([y_tagged_node, (t4, True), (x, False)])

      x_entry, x_came_from_max_bearing_node = x_tagged_entry

      x_max_value = self._getMaxValue(x_entry)

      x_max_node = x_entry.getLocation()

      x_tagged_node = (x_max_node, x_came_from_max_bearing_node)

      self._setMaxValue(x, x_entry)

      self._setMaxValue(y, y_entry)

      self._setMaxValue(z, z_entry)

    SplayTree._zig_zig(self, x)

  def _zig_zag(self, x):

    # take care of max values

    y = x.getParent()

    z = y.getParent()

    if x.isRightChild() == True:

      # left, right

      t1 = y.getLeftChild()

      t2 = x.getLeftChild()

      t3 = x.getRightChild()

      t4 = z.getRightChild()

      y_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([(t1, True), (t2, True), (z, False)])

      y_entry, y_came_from_max_bearing_node = y_tagged_entry

      y_max_value = self._getMaxValue(y_entry)

      y_max_node = y_entry.getLocation()

      y_tagged_node = (y_max_node, y_came_from_max_bearing_node)

      z_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([z_tagged_node, (t3, True), (y, False)])

      z_entry, z_came_from_max_bearing_node = z_tagged_entry

      z_max_value = self._getMaxValue(z_entry)

      z_max_node = z_entry.getLocation()

      z_tagged_node = (z_max_node, z_came_from_max_bearing_node)

      x_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([y_tagged_node, (t4, True), (x, False)])

      x_entry, x_came_from_max_bearing_node = x_tagged_entry

      x_max_value = self._getMaxValue(x_entry)

      x_max_node = x_entry.getLocation()

      x_tagged_node = (x_max_node, x_came_from_max_bearing_node)

      self._setMaxValue(x, x_entry)

      self._setMaxValue(y, y_entry)

      self._setMaxValue(z, z_entry)

    else:

      # right, left

      t1 = z.getLeftChild()

      t2 = x.getLeftChild()

      t3 = x.getRightChild()

      t4 = y.getRightChild()
      
      y_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([(t1, True), (t2, True), (z, False)])

      y_entry, y_came_from_max_bearing_node = y_tagged_entry

      y_max_value = self._getMaxValue(y_entry)

      y_max_node = y_entry.getLocation()

      y_tagged_node = (y_max_node, y_came_from_max_bearing_node)

      z_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([(t3, True), (t4, True), (y, False)])

      z_entry, z_came_from_max_bearing_node = z_tagged_entry

      z_max_value = self._getMaxValue(z_entry)

      z_max_node = z_entry.getLocation()

      z_tagged_node = (z_max_node, z_came_from_max_bearing_node)

      x_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([z_tagged_node, y_tagged_node, (x, False)])

      x_entry, x_came_from_max_bearing_node = x_tagged_entry

      x_max_value = self._getMaxValue(x_entry)

      x_max_node = x_entry.getLocation()

      x_tagged_node = (x_max_node, x_came_from_max_bearing_node)

      self._setMaxValue(x, x_entry)

      self._setMaxValue(y, y_entry)

      self._setMaxValue(z, z_entry)

    SplayTree._zig_zag(self, x)

  def _zig(self, x):

    # take care of max values

    y = x.getParent()

    w1 = x.getLeftChild()

    w2 = x.getRightChild()

    if x.isLeftChild() == True:

      # left

      t3 = x.getRightChild()

      t4 = y.getRightChild()

      y_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([(t1, True), (t2, True), (y, False)])

      y_entry, y_came_from_max_bearing_node = y_tagged_entry

      y_max_value = self._getMaxValue(y_entry)

      y_max_node = y_entry.getLocation()

      y_tagged_node = (y_max_node, y_came_from_max_bearing_node)

      x_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([(w1, True), y_tagged_entry, (x, False)])

      x_entry, x_came_from_max_bearing_node = x_tagged_entry

      x_max_value = self._getMaxValue(x_entry)

      x_max_node = x_entry.getLocation()

      x_tagged_node = (x_max_node, x_came_from_max_bearing_node)

      self._setMaxValue(x, x_entry)

      self._setMaxValue(y, y_entry)

    else:

      # right

      t1 = y.getLeftChild()

      t2 = x.getLeftChild()

      y_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([(t1, True), (t2, True), (y, False)])

      y_entry, y_came_from_max_bearing_node = y_tagged_entry

      y_max_value = self._getMaxValue(y_entry)

      y_max_node = y_entry.getLocation()

      y_tagged_node = (y_max_node, y_came_from_max_bearing_node)

      x_tagged_entry = self.getTaggedMediatingEntryGivenTaggedCandidateNodes([y_tagged_entry, (w2, True), (x, False)])

      x_entry, x_came_from_max_bearing_node = x_tagged_entry

      x_max_value = self._getMaxValue(x_entry)

      x_max_node = x_entry.getLocation()

      x_tagged_node = (x_max_node, x_came_from_max_bearing_node)

      self._setMaxValue(x, x_entry)

      self._setMaxValue(y, y_entry)

    SplayTree._zig(self, x)

  # retrieve a node corresponding to one overlapped interval, 
  #   with ties between intervals resolved arbitrarily
  
  # interval is an interval object
  
  # return an (entry, node) pair

  # takes O(log(n)) time

  def intervalSearch(self, interval):

    node = self._intervalSearchHelper(interval, None, self.getRoot())

    entry = node.getElement()

    return (entry, node)

  # assume the tree is not empty

  # returns an internal node 
  #   or an external node 
  #   where interval should go

  def _intervalSearchHelper(self, interval, prev_node, curr_node):

    print "interval search - interval:", interval.toString()

    if curr_node.isExternal() == True:

      return prev_node

    else:

      curr_interval = curr_node.getElement().getKey()

      print "interval search - current interval:", curr_interval.toString()

      if curr_interval.overlapsInterval(interval):

        print "interval search - interval overlap:", curr_interval.toString(), interval.toString()

        return curr_node

      # travel in a safe direction

      have_left_child = curr_node.hasLeftChild()

      left_endpoint = interval.getLeftEndpoint()

      if have_left_child == True:

        print "max value:", curr_node.getLeftChild().getMax()

      look_at_left = have_left_child and curr_node.getLeftChild().getMax() >= left_endpoint

      look_at_right = not look_at_left

      if look_at_left == True:

        return self._intervalSearchHelper(interval, curr_node, curr_node.getLeftChild())

      elif look_at_right == True:

        return self._intervalSearchHelper(interval, curr_node, curr_node.getRightChild())

  """

  # retrieve a node corresponding to one overlapped interval, 
  #   with ties between intervals resolved arbitrarily
  
  # i is an interval object
  
  # return an (entry, node) pair

  # if no overlapped interval, return None

  def intervalSearch(self, i):

    node = self._intervalSearch(i)

    print node == None

    if node == None:

      return None

    interval = node.getElement().getKey()

    entry = node.getElement()

    if interval.overlapsInterval(i):

      return (entry, node)

    else:

      return None

  # assume the tree is not empty

  # returns a node

  def _intervalSearch(self, i):

    x = self.getRoot()

    if self.isEmpty() == True:

      raise Exception("tree is empty")
    
    curr_interval = x.getElement().getKey()

    # print x.getElement().toString()

    # print curr_interval

    # print x.getMax()
    
    while x != None and not curr_interval.overlapsInterval(i):

      if x.hasLeftChild() == True \
        and x.getLeftChild().getMax() >= i.getLeftEndpoint():

        x = x.getLeftChild()
      
      else:
      
        x = x.getRightChild()
        
    return x

  """

  """

  def _toString(self, node):

    if node == None:

      # non-existent node

      return "None"

    else:

      left_child_str = self._toString(node.getLeftChild())

      curr_element = node.getElement()

      if curr_element != None:

        curr_entry_str = str(self.getKeyString(node))

      else:

        # non-existent key (possibly because entry does not exist)

        curr_entry_str = "None"

      right_child_str = self._toString(node.getRightChild())

      partial_str = "(" + curr_entry_str + " " + left_child_str + " " + right_child_str + ")"

      return partial_str

  def getKeyString(self, node):

    entry = node.getElement()

    interval = entry.getKey()

    left_endpoint = interval.getLeftEndpoint()

    right_endpoint = interval.getRightEndpoint()

    result_str = "[" + str(left_endpoint) + ", " + str(right_endpoint) + "]"

    return result_str

  """

  def toIntervalList(self):

    internal_node_list = self.toInorderInternalNodeList()

    interval_list = [x.getElement().getKey() for x in internal_node_list]

    return interval_list

  def toIntervalStringList(self):

    interval_list = self.toIntervalList()

    interval_string_list = [x.toString() for x in interval_list]

    return interval_string_list

# node can be non-existent, 
# in which case it would be None; 
# in this case, we return None

def getMax(node):

  if node == None:
  
    return None
    
  else:
  
    return node.getMax()
    
# node can have no entry; 
# in this case, we return None

def getRightEndpointUsingNode(node):

  if node.getElement() == None:
  
    return None
    
  else:
  
    return node.getElement().getKey().getRightEndpoint()



t1 = BalancedIntervalTree.construct([(Interval(0, 1), 1), (Interval(1, 2), 1), (Interval(2, 3), 1)])

# print t1.toString()

print t1.toInorderList()

t1.intervalInsert(Interval(3, 4), 1)

# print t1.toString()

print t1.toInorderList()

t1.intervalDelete(Interval(1, 2), 1)

# print t1.toString()

print t1.toInorderList()

print t1.intervalSearch(Interval(2.5, 2.5))

t2 = BalancedIntervalTree.construct([(Interval(1, 11), 1), (Interval(2, 12), 1), (Interval(4, 14), 1), (Interval(3, 5), 1), (Interval(0, 10), 1)])

print t2.toString()

print t2.toInorderList()



"""

from SweepLineTouchingSlab import *

from LeadingSweepLineTouchingSlab import *

from TrailingSweepLineTouchingSlab import *

from SweepLineTouchingSlabInterval import *

from ..SweepLine import *

t2 = BalancedIntervalTree.construct([(Interval(0, 1), 1), (Interval(1, 2), 1), (Interval(2, 3), 1)])

sweep_line = SweepLine()

sweep_line.setY(3)

slab1 = SweepLineTouchingSlab(3, 4, sweep_line)

slab_interval1 = SweepLineTouchingSlabInterval(slab1)

t2.intervalInsert(slab_interval1, 1)

slab2 = TrailingSweepLineTouchingSlab(4, sweep_line)

slab_interval2 = SweepLineTouchingSlabInterval(slab2)

t2.intervalInsert(slab_interval2, 1)

slab3 = LeadingSweepLineTouchingSlab(0, sweep_line)

slab_interval3 = SweepLineTouchingSlabInterval(slab3)

t2.intervalInsert(slab_interval3, 1)

print t2.toIntervalStringList()

"""


