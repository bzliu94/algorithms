from ...tree.bbst.SplayTree import *

from ...tree.Entry import *

from IntervalTreeNode import *

from Interval import *

from IntervalEntry import *

# maintain for each node a max field 
# for storing max value of a right endpoint 
# of an interval in the subtree 
# rooted at the node

# use as key the interval

# internally, use left endpoint as key

class BalancedIntervalTree(SplayTree):

  def __init__(self, key_transform = lambda x: x.getLeftEndpoint(), comparator = comp):

    # key internal representation is an interval object

    # transformed key is interval left endpoint

    # key_transform = lambda x: x.getLeftEndpoint()

    SplayTree.__init__(self, key_transform, comparator)

  # entries are (interval, value) pairs

  @staticmethod

  def construct(entries):

    tree = BalancedIntervalTree()

    for entry in entries:

      key, value = entry

      tree.intervalInsert(key, value)

    return tree
    
  def _expandExternal(self, external_node, left_entry, right_entry):
  
    self._expandExternalHelper(external_node, left_entry, right_entry, IntervalTreeNode)
    
  def addRoot(self, entry):

    self._addRootHelper(entry, IntervalTreeNode)

  # return an entry
  
  def _insertIntroduceEntry(self, key, value, ins_node):
  
    return self._insertAtExternal(ins_node, IntervalEntry(key, value))

  # return an (entry, node) pair
    
  def _insertWithUntransformedKeyForTree(self, untransformed_key, value):

    # return self._insertHelper(untransformed_key, value, self._treeSearchWithUntransformedKey)

    return self.insert(untransformed_key, value)

  # remove an entry with matching (transformed) key

  # note: entry provided should involve untransformed key

  # return an (entry, node) pair

  def _removeForTree(self, entry):

    # return self._removeHelper(entry, self._treeSearch)
    
    return self.remove(entry)

  """

  # return an (entry, node) pair

  def _removeForTree(self, entry_with_transformed_key):

    # return self._removeHelper(entry_with_transformed_key, self._treeSearch)
    
    return self.remove(entry_with_transformed_key)

  """

  """
    
  # return an (entry, node) pair
  
  def _removeWithUntransformedKeyForTree(self, entry_with_untransformed_key):

    # return self._removeHelper(entry_with_untransformed_key, self._treeSearchWithUntransformedKey)
    
    return self.removeWithUntransformedKey(entry_with_untransformed_key)

  """
    
  """

  # return an entry
    
  def insert(self, transformed_key, value):
  
    return (self._insertForTree(transformed_key, value))[0]

  # return an entry

  def remove(self, entry_with_transformed_key):
  
    return (self._removeForTree(entry_with_transformed_key))[0]

  """

  """

  # do not assume node is an internal node

  def _updateMaxValuesForParents(self, node):

    if node.isExternal() == True:

      return

  """

  # update max values for node and its parents

  # do not assume node is an internal node

  def _updateMaxValuesForParents(self, node):
  
    if node == self.getRoot():
    
      return

    elif node.isExternal() == True:

      self._updateMaxValuesForParents(node.getParent())

    elif node.isExternal() == False:
    
      candidate_values = []
      
      if node.hasLeftChild() == True:
      
        candidate_values.append(node.getLeftChild().getMax())
        
      if node.hasRightChild() == True:
      
        candidate_values.append(node.getRightChild().getMax())
        
      curr_right_endpoint = node.getElement().getKey().getRightEndpoint()
      
      candidate_values.append(curr_right_endpoint)
      
      next_max_value = max(candidate_values)
      
      node.setMax(next_max_value)
      
      self._updateMaxValuesForParents(node.getParent())

  # i is an interval and has form of an Interval object
  
  # return an (entry, node) pair

  def intervalInsert(self, i, value):

    """

    if i.getLeftEndpoint() > i.getRightEndpoint():

      print i.getLeftEndpoint(), i.getRightEndpoint()

      raise Exception("unexpected endpoints with insertion of an interval")

    """
  
    # actually insert

    entry, node = self._insertWithUntransformedKeyForTree(i, value)
    
    # take care of inserted node's max value
    
    right_endpoint = i.getRightEndpoint()
    
    # print "introduced interval's right_endpoint:", right_endpoint
    
    node.setMax(right_endpoint)
    
    """
    
    # take care of max values

    tree_search = self._treeSearchWithUntransformedKey
    
    ins_node = self._insertRetrieveNode(i, value, tree_search)
  
    self._updateMaxValuesForParents(ins_node)
    
    """
    
    # take care of max values
    
    self._updateMaxValuesForParents(node)

    return (entry, node)

  # i is an interval and has form of an Interval object
  
  # return an (entry, node) pair

  def intervalDelete(self, i, value):

    # entry, node = self.find(i)

    # print entry.toString()

    # raise Exception("attempting to remove an interval")

    """

    interval_entries = self.findAll(i.getLeftEndpoint())

    matching_interval_entries = [x for x in interval_entries if x[0].isEqualTo(i)]

    chosen_interval_entry = matching_intervals[0]

    self.remove(IntervalEntry((chosen_interval_entry[0]).getLeftEndpoint(), value))

    """
    
    # for taking care of max values
    
    # tree_search = self._treeSearchWithUntransformedKey

    # print "interval to be removed:", i.toString(), value
    
    # w = self.removeRetrieveNode(IntervalEntry(i, value), tree_search)
    
    w = self._removeRetrieveNode(IntervalEntry(i, value))

    """

    print w.isExternal()

    print self.toString()

    """
    
    rem_node = self._removeRetrieveReplacementNode(w)
    
    rem_node_sibling = rem_node.getSibling()
    
    """

    # actually remove

    self.removeWithUntransformedKey(IntervalEntry(i, value))
    
    """
    
    # actually remove
    
    # entry, node = self._removeWithUntransformedKeyForTree(IntervalEntry(i, value))

    entry, node = self._removeForTree(IntervalEntry(i, value))
    
    # take care of max values
    
    self._updateMaxValuesForParents(rem_node_sibling)
    
    return (entry, node)

    """
    
    # actually remove
    
    entry, node = self._removeForTree(i, value)
    
    # take care of max values
    
    self._updateMaxValuesForParents(node)

    """

  def _zig_zig(self, x):

    # take care of max values

    y = x.getParent()

    z = y.getParent()

    if x.isLeftChild() == True:

      # left, left

      t1 = x.getLeftChild()

      t2 = x.getRightChild()

      t3 = y.getRightChild()

      t4 = z.getRightChild()
      
      """
      
      print x, y, z
      
      print t1, t2, t3, t4
      
      """
      
      z_max_candidates = [getMax(t3), getMax(t4), getRightEndpointUsingNode(z)]
      
      z_max_candidates_winnowed = [c for c in z_max_candidates if c != None]
      
      z_max = max(z_max_candidates_winnowed)
      
      y_max_candidates = [getMax(t2), z_max, getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      x_max_candidates = [getMax(t1), y_max, getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

      z.setMax(z_max)

    else:

      # right, right

      t1 = z.getLeftChild()

      t2 = y.getLeftChild()

      t3 = x.getLeftChild()

      t4 = x.getRightChild()
      
      z_max_candidates = [getMax(t1), getMax(t2), getRightEndpointUsingNode(z)]
      
      z_max_candidates_winnowed = [c for c in z_max_candidates if c != None]
      
      z_max = max(z_max_candidates_winnowed)
      
      y_max_candidates = [z_max, getMax(t3), getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      x_max_candidates = [y_max, getMax(t4), getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

      z.setMax(z_max)

    SplayTree._zig_zig(self, x)

  def _zig_zag(self, x):

    # take care of max values

    y = x.getParent()

    z = y.getParent()

    if x.isRightChild() == True:

      # left, right

      t1 = y.getLeftChild()

      t2 = x.getLeftChild()

      t3 = x.getRightChild()

      t4 = z.getRightChild()
      
      y_max_candidates = [getMax(t1), getMax(t2), getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      z_max_candidates = [getMax(t3), getMax(t4), getRightEndpointUsingNode(z)]
      
      z_max_candidates_winnowed = [c for c in z_max_candidates if c != None]
      
      z_max = max(z_max_candidates_winnowed)
      
      x_max_candidates = [y_max, z_max, getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

      z.setMax(z_max)

    else:

      # right, left

      t1 = z.getLeftChild()

      t2 = x.getLeftChild()

      t3 = x.getRightChild()

      t4 = y.getRightChild()
      
      z_max_candidates = [getMax(t1), getMax(t2), getRightEndpointUsingNode(z)]
      
      z_max_candidates_winnowed = [c for c in z_max_candidates if c != None]
      
      z_max = max(z_max_candidates_winnowed)
      
      y_max_candidates = [getMax(t3), getMax(t4), getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      x_max_candidates = [z_max, y_max, getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

      z.setMax(z_max)

    SplayTree._zig_zag(self, x)

  def _zig(self, x):

    # take care of max values

    y = x.getParent()

    w1 = x.getLeftChild()

    w2 = x.getRightChild()

    if x.isLeftChild() == True:

      # left

      t3 = x.getRightChild()

      t4 = y.getRightChild()
      
      y_max_candidates = [getMax(t3), getMax(t4), getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      x_max_candidates = [getMax(w1), y_max, getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

    else:

      # right

      t1 = y.getLeftChild()

      t2 = x.getLeftChild()
      
      y_max_candidates = [getMax(t1), getMax(t2), getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      x_max_candidates = [y_max, getMax(w2), getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

    SplayTree._zig(self, x)

  # retrieve a node corresponding to one overlapped interval, 
  #   with ties between intervals resolved arbitrarily
  
  # interval is an interval object
  
  # return an (entry, node) pair

  # takes O(log(n)) time

  def intervalSearch(self, interval):

    node = self._intervalSearchHelper(interval, None, self.getRoot())

    entry = node.getElement()

    return (entry, node)
    
  # assume the tree is not empty

  # returns a node

  def _intervalSearchHelper(self, interval, prev_node, curr_node):

    if curr_node.isExternal() == True:

      return prev_node

    else:

      curr_interval = curr_node.getElement().getKey()

      if curr_interval.overlapsInterval(interval):

        return curr_node

      # travel in a safe direction

      have_left_child = curr_node.hasLeftChild()

      left_endpoint = interval.getLeftEndpoint()

      look_at_left = have_left_child and curr_node.getLeftChild().getMax() >= left_endpoint

      look_at_right = not look_at_left

      if look_at_left == True:

        return self._intervalSearchHelper(interval, curr_node, curr_node.getLeftChild())

      elif look_at_right == True:

        return self._intervalSearchHelper(interval, curr_node, curr_node.getRightChild())

  """

  # retrieve a node corresponding to one overlapped interval, 
  #   with ties between intervals resolved arbitrarily
  
  # i is an interval object
  
  # return an (entry, node) pair

  # if no overlapped interval, return None

  def intervalSearch(self, i):

    node = self._intervalSearch(i)

    print node == None

    if node == None:

      return None

    interval = node.getElement().getKey()

    entry = node.getElement()

    if interval.overlapsInterval(i):

      return (entry, node)

    else:

      return None

  # assume the tree is not empty

  # returns a node

  def _intervalSearch(self, i):

    x = self.getRoot()

    if self.isEmpty() == True:

      raise Exception("tree is empty")
    
    curr_interval = x.getElement().getKey()

    # print x.getElement().toString()

    # print curr_interval

    # print x.getMax()
    
    while x != None and not curr_interval.overlapsInterval(i):

      if x.hasLeftChild() == True \
        and x.getLeftChild().getMax() >= i.getLeftEndpoint():

        x = x.getLeftChild()
      
      else:
      
        x = x.getRightChild()
        
    return x

  """

  """

  def _toString(self, node):

    if node == None:

      # non-existent node

      return "None"

    else:

      left_child_str = self._toString(node.getLeftChild())

      curr_element = node.getElement()

      if curr_element != None:

        curr_entry_str = str(self.getKeyString(node))

      else:

        # non-existent key (possibly because entry does not exist)

        curr_entry_str = "None"

      right_child_str = self._toString(node.getRightChild())

      partial_str = "(" + curr_entry_str + " " + left_child_str + " " + right_child_str + ")"

      return partial_str

  def getKeyString(self, node):

    entry = node.getElement()

    interval = entry.getKey()

    left_endpoint = interval.getLeftEndpoint()

    right_endpoint = interval.getRightEndpoint()

    result_str = "[" + str(left_endpoint) + ", " + str(right_endpoint) + "]"

    return result_str

  """

  def toIntervalList(self):

    internal_node_list = self.toInorderInternalNodeList()

    interval_list = [x.getElement().getKey() for x in internal_node_list]

    return interval_list

  def toIntervalStringList(self):

    interval_list = self.toIntervalList()

    interval_string_list = [x.toString() for x in interval_list]

    return interval_string_list

# node can be non-existent, 
# in which case it would be None; 
# in this case, we return None

def getMax(node):

  if node == None:
  
    return None
    
  else:
  
    return node.getMax()
    
# node can have no entry; 
# in this case, we return None

def getRightEndpointUsingNode(node):

  if node.getElement() == None:
  
    return None
    
  else:
  
    return node.getElement().getKey().getRightEndpoint()

"""

t1 = BalancedIntervalTree.construct([(Interval(0, 1), 1), (Interval(1, 2), 1), (Interval(2, 3), 1)])

# print t1.toString()

print t1.toInorderList()

t1.intervalInsert(Interval(3, 4), 1)

# print t1.toString()

print t1.toInorderList()

t1.intervalDelete(Interval(1, 2), 1)

# print t1.toString()

print t1.toInorderList()

print t1.intervalSearch(Interval(2.5, 2.5))

t2 = BalancedIntervalTree.construct([(Interval(1, 11), 1), (Interval(2, 12), 1), (Interval(4, 14), 1), (Interval(3, 5), 1), (Interval(0, 10), 1)])

print t2.toString()

print t2.toInorderList()

"""

"""

from SweepLineTouchingSlab import *

from LeadingSweepLineTouchingSlab import *

from TrailingSweepLineTouchingSlab import *

from SweepLineTouchingSlabInterval import *

from ..SweepLine import *

t2 = BalancedIntervalTree.construct([(Interval(0, 1), 1), (Interval(1, 2), 1), (Interval(2, 3), 1)])

sweep_line = SweepLine()

sweep_line.setY(3)

slab1 = SweepLineTouchingSlab(3, 4, sweep_line)

slab_interval1 = SweepLineTouchingSlabInterval(slab1)

t2.intervalInsert(slab_interval1, 1)

slab2 = TrailingSweepLineTouchingSlab(4, sweep_line)

slab_interval2 = SweepLineTouchingSlabInterval(slab2)

t2.intervalInsert(slab_interval2, 1)

slab3 = LeadingSweepLineTouchingSlab(0, sweep_line)

slab_interval3 = SweepLineTouchingSlabInterval(slab3)

t2.intervalInsert(slab_interval3, 1)

print t2.toIntervalStringList()

"""

