from BalancedOrderedIntervalTree import *

# from OrderedIntervalTreeNode import *

from ArcInterval import *

# stored keys are arcs

# from an arc, we can retrieve an interval involving endpoints that depend on sweep-line location

# transformed keys are left endpoints

# values are arcs

# key is a tuple (a, b), with:
# a: interval left endpoint
# b: angle precursor corresponding to angle 
#      between vector from left endpoint 
#      to arc focus and downward vector

class ArcTree(BalancedOrderedIntervalTree):

  def __init__(self, sweep_line):

    BalancedOrderedIntervalTree.__init__(self)

    self.sweep_line = sweep_line
    
    self.arc_to_interval_map = {}

  def getSweepLine(self):

    return self.sweep_line

  """
    
  def _expandExternal(self, external_node, left_entry, right_entry):
  
    self._expandExternalHelper(external_node, left_entry, right_entry, OrderedIntervalTreeNode)

  def addRoot(self, entry):

    self._addRootHelper(entry, OrderedIntervalTreeNode)

  """
    
  def _addArcToIntervalRelationship(self, arc, interval):
  
    (self.arc_to_interval_map)[arc] = interval
    
  def _removeArcToIntervalRelationship(self, arc, interval):
  
    (self.arc_to_interval_map).pop(arc)
    
  def _getIntervalForArc(self, arc):
  
    return (self.arc_to_interval_map)[arc]

  ######################
  ## FOR EXTERNAL USE ##
  ######################
  
  # add arc to collection as left-most arc

  # does not return anything
  
  def insertArcAsFirst(self, arc, payload):

    # create an interval
  
    sweep_line = self.getSweepLine()

    arc_interval = ArcInterval(arc, self, sweep_line)

    # actually insert an arc interval
  
    tree_node = self._addIntervalAsFirstHelper(arc_interval, payload)

    # make note of introduced (arc, interval) pair
  
    self._addArcToIntervalRelationship(arc, arc_interval)
  
  # add arc to collection after a particular arc
  
  # does not return anything

  def insertArcAfter(self, reference_arc, arc, payload):

    sweep_line = self.getSweepLine()

    # retrieve an arc interval
  
    reference_arc_interval = self._getIntervalForArc(reference_arc)
  
    # create an interval
  
    arc_interval = ArcInterval(arc, self, sweep_line)

    # actually insert an arc interval
  
    tree_node = self._addIntervalAfterHelper(reference_arc_interval, arc_interval, payload)

    # make note of introduced (arc, interval) pair
  
    self._addArcToIntervalRelationship(arc, arc_interval)
  
  # remove arc from collection

  # does not return anything

  def removeArc(self, arc):

  # retrieve an arc interval

    interval = self._getIntervalForArc(arc)

    node = self._removeIntervalHelper(interval)
  
    # make note of removal of (arc, interval) pair
  
    self._removeArcToIntervalRelationship(arc, interval)
  
  # retrieve arc above a location on sweep-line 
  #   given an x value and location of sweep-line

  # returns an (arc, payload) tuple

  # raises an exception if there is nothing above the query location

  def query(self, x):

    interval = Interval(x, x)

    result = self.intervalSearch(interval)

    if result == None:

      raise Exception("no arc above query location")

    result_interval, result_node = result

    entry = result_node.getElement()

    arc_interval = entry.getKey()

    arc = arc_interval._getArc()

    payload = entry.getValue()

    return (arc, payload)
  
  # check whether an arc has a left neighbor
  
  def arcHasLeftNeighbor(self, arc):

    interval = self._getIntervalForArc(arc)
  
    return self.intervalHasLeftNeighbor(interval)
  
  # check whether an arc has a right neighbor

  def arcHasRightNeighbor(self, arc):

    interval = self._getIntervalForArc(arc)
  
    return self.intervalHasRightNeighbor(interval)

  # get for an arc a left neighbor; 
  #   specifically, returns an (arc, payload) tuple

  def getArcLeftNeighbor(self, arc):

    interval = self._getIntervalForArc(arc)
  
    result_interval = self.getLeftNeighboringInterval(interval)

    result_arc = result_interval._getArc()

    return result_arc
  
  # get for an arc a right neighbor arc; 
  #   specifically, returns an (arc, payload) tuple

  def getArcRightNeighbor(self, arc):

    interval = self._getIntervalForArc(arc)

    result_interval = self.getRightNeighboringInterval(interval)

    result_arc = result_interval._getArc()

    return result_arc
    
  # return an (arc, payload) tuple
  
  def getArcWithPayload(self, arc):
  
    print self.toString()
  
    interval = self._getIntervalForArc(arc)
    
    """
    
    key = interval
  
    entry = self.find(key)
    
    """
    
    key = interval
    
    print "payload being retrieved for interval:", interval
  
    entry = self.findWithUntransformedKey(key)
    
    found_interval = entry.getKey()
    
    found_value = entry.getValue()

    found_arc = found_interval._getArc()
    
    arc_payload = found_value
    
    to_return = found_arc, found_value
    
    return to_return

  # assume that we have entries, and keys cannot be None

  def toString(self):

    return self._toString(self.getRoot())

  def _toString(self, node):

    if node == None:

      # non-existent node

      return "None"

    else:

      left_child_str = self._toString(node.getLeftChild())

      curr_element = node.getElement()

      if curr_element != None:
      
        curr_entry = node.getElement()
        
        arc_interval = curr_entry.getKey()
        
        curr_entry_str = arc_interval.toString()

      else:

        # non-existent key (possibly because entry does not exist)

        curr_entry_str = "None"

      right_child_str = self._toString(node.getRightChild())

      partial_str = "(" + curr_entry_str + " " + left_child_str + " " + right_child_str + ")"

      return partial_str

