from BalancedIntervalTree import *

from OrderedIntervalTreeNode import *

# maintain predecessor and successor pointers for each node

# modify mutator methods

class BalancedOrderedIntervalTree(BalancedIntervalTree):

  def __init__(self):

    BalancedIntervalTree.__init__(self)

  @staticmethod

  def construct(entries):

    tree = BalancedOrderedIntervalTree()

    for entry in entries:

      key, value = entry

      tree.orderedIntervalInsert(key, value)

    return tree

  def _expandExternal(self, external_node, left_entry, right_entry):
  
    self._expandExternalHelper(external_node, left_entry, right_entry, OrderedIntervalTreeNode)
    
  def addRoot(self, entry):

    self._addRootHelper(entry, OrderedIntervalTreeNode)

  # takes O(log(n)) time

  def orderedIntervalInsert(self, interval, value):

    entry, node = self.intervalInsert(interval, value)

    prev = self._getPredecessorInteriorNode(node)

    next = self._getSuccessorInteriorNode(node)

    node.setPrev(prev)

    node.setNext(next)

  # takes O(log(n)) time

  def orderedIntervalDelete(self, interval):

    entry, node = self.intervalDelete(interval)

    prev = node.getPrev()

    next = node.getNext()

    prev.setNext(next)

    next.setPrev(prev)

  # takes O(1) time

  def getPredecessorInteriorNode(self, node):

    return node.getPrev()

  # takes O(1) time

  def getSuccessorInteriorNode(self, node):

    return node.getNext()

  def _getMinimumInteriorNode(self, node):

    if node.isExternal() == True:

      return node

    else:

      return self._getMinimum(node.getLeftChild())

  def _getMaximumInteriorNode(self, node):

    if node.isExternal() == True:

      return node

    else:

      return self._getMinimum(node.getRightChild())

  def _getClosestAncestorWithLeftChild(self, node):

    if self.getRoot() == node:

      return None

    else:

      return self._getClosestAncestorWithLeftChildHelper(node.getParent())

  def _getClosestAncestorWithLeftChildHelper(self, node):

    if node.hasLeftChild() == True:

      return node

    else:

      return self._getClosestAncestorWithLeftChildHelper(node.getParent())

  def _getClosestAncestorWithRightChild(self, node):

    if self.getRoot() == node:

      return None

    else:

      return self._getClosestAncestorWithLeftChildHelper(node.getParent())

  def _getClosestAncestorWithRightChildHelper(self, node):

    if node.hasRightChild() == True:

      return node

    else:

      return self._getClosestAncestorWithRightChildHelper(node.getParent())

  # retrieves a predecessor interior node

  # takes as input a node that is an interior node

  # returns a node

  # takes O(log(n)) time

  def _getPredecessorInteriorNode(self, node):

    if node.getLeftChild().isExternal() == False:

      return self._getMaximum(node.getLeftChild())

    else:

      return self._getClosestAncestorWithRightChild(node)

  # takes O(log(n)) time

  def _getSuccessorInteriorNode(self, node):

    if node.getRightChild().isExternal() == False:

      return self._getMinimum(node.getRightChild())

    else:

      return self._getClosestAncestorWithLeftChild(node)

t1 = BalancedOrderedIntervalTree.construct([(Interval(0, 1), 1), (Interval(1, 2), 1), (Interval(2, 3), 1)])

print t1.toString()

entry, node = t1.intervalSearch(Interval(2.5, 2.5))

print node.getElement().toString()

predecessor_node = t1.getPredecessorInteriorNode(node)

print predecessor_node.getElement().toString()

"""

# print t1.toString()

print t1.toInorderList()

t1.intervalInsert(Interval(3, 4), 1)

# print t1.toString()

print t1.toInorderList()

t1.intervalDelete(Interval(1, 2), 1)

# print t1.toString()

print t1.toInorderList()

print t1.intervalSearch(Interval(2.5, 2.5))

t2 = BalancedIntervalTree.construct([(Interval(1, 11), 1), (Interval(2, 12), 1), (Interval(4, 14), 1), (Interval(3, 5), 1), (Interval(0, 10), 1)])

print t2.toString()

print t2.toInorderList()

"""

