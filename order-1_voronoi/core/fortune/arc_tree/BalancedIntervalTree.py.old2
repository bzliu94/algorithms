from ...tree.bbst.SplayTree import *

from ...tree.Entry import *

from BalancedIntervalTreeNode import *

from Interval import *

from IntervalEntry import *

# maintain for each node a max field 
# for storing max value of a right endpoint 
# of an interval in the subtree 
# rooted at the node

# use as key the interval

# internally, use left endpoint as key

class BalancedIntervalTree(SplayTree):

  def __init__(self, key_transform = lambda x: x.getLeftEndpoint(), comparator = comp):

    # key internal representation is an interval object

    # transformed key is interval left endpoint

    # key_transform = lambda x: x.getLeftEndpoint()

    SplayTree.__init__(self, key_transform, comparator)

  # entries are (interval, value) pairs

  @staticmethod

  def construct(entries):

    tree = BalancedIntervalTree()

    for entry in entries:

      key, value = entry

      tree.intervalInsert(key, value)

    return tree
    
  def _expandExternal(self, external_node, left_entry, right_entry):
  
    self._expandExternalHelper(external_node, left_entry, right_entry, BalancedIntervalTreeNode)
    
  def addRoot(self, entry):

    self._addRootHelper(entry, BalancedIntervalTreeNode)

  # return an entry
  
  def _insertIntroduceEntry(self, key, value, ins_node):
  
    return self._insertAtExternal(ins_node, IntervalEntry(key, value))

  # return an (entry, node) pair
    
  def _insertWithUntransformedKeyForTree(self, untransformed_key, value):

    # return self._insertHelper(untransformed_key, value, self._treeSearchWithUntransformedKey)

    return self.insert(untransformed_key, value)

  # remove an entry with matching (transformed) key

  # note: entry provided should involve untransformed key

  # return an (entry, node) pair

  def _removeForTree(self, entry):

    # return self._removeHelper(entry, self._treeSearch)
    
    return self.remove(entry)

  """

  # return an (entry, node) pair

  def _removeForTree(self, entry_with_transformed_key):

    # return self._removeHelper(entry_with_transformed_key, self._treeSearch)
    
    return self.remove(entry_with_transformed_key)

  """

  """
    
  # return an (entry, node) pair
  
  def _removeWithUntransformedKeyForTree(self, entry_with_untransformed_key):

    # return self._removeHelper(entry_with_untransformed_key, self._treeSearchWithUntransformedKey)
    
    return self.removeWithUntransformedKey(entry_with_untransformed_key)

  """
    
  """

  # return an entry
    
  def insert(self, transformed_key, value):
  
    return (self._insertForTree(transformed_key, value))[0]

  # return an entry

  def remove(self, entry_with_transformed_key):
  
    return (self._removeForTree(entry_with_transformed_key))[0]

  """

  """

  # do not assume node is an internal node

  def _updateMaxValuesForParents(self, node):

    if node.isExternal() == True:

      return

  """

  # update max values for node and its parents

  # do not assume node is an internal node

  def _updateMaxValuesForParents(self, node):
  
    if node == self.getRoot():
    
      return

    elif node.isExternal() == True:

      self._updateMaxValuesForParents(node.getParent())

    elif node.isExternal() == False:
    
      candidate_values = []
      
      if node.hasLeftChild() == True:
      
        candidate_values.append(node.getLeftChild().getMax())
        
      if node.hasRightChild() == True:
      
        candidate_values.append(node.getRightChild().getMax())
        
      curr_right_endpoint = node.getElement().getKey().getRightEndpoint()
      
      candidate_values.append(curr_right_endpoint)
      
      next_max_value = max(candidate_values)
      
      node.setMax(next_max_value)
      
      self._updateMaxValuesForParents(node.getParent())

  # i is an interval and has form of an Interval object
  
  # return an (entry, node) pair

  def intervalInsert(self, i, value):

    """

    if i.getLeftEndpoint() > i.getRightEndpoint():

      print i.getLeftEndpoint(), i.getRightEndpoint()

      raise Exception("unexpected endpoints with insertion of an interval")

    """
  
    # actually insert

    entry, node = self._insertWithUntransformedKeyForTree(i, value)
    
    # take care of inserted node's max value
    
    right_endpoint = i.getRightEndpoint()
    
    # print "introduced interval's right_endpoint:", right_endpoint
    
    node.setMax(right_endpoint)
    
    """
    
    # take care of max values

    tree_search = self._treeSearchWithUntransformedKey
    
    ins_node = self._insertRetrieveNode(i, value, tree_search)
  
    self._updateMaxValuesForParents(ins_node)
    
    """
    
    # take care of max values
    
    self._updateMaxValuesForParents(node)

    return (entry, node)

  # i is an interval and has form of an Interval object
  
  # return an (entry, node) pair

  def intervalDelete(self, i, value):

    # entry, node = self.find(i)

    # print entry.toString()

    # raise Exception("attempting to remove an interval")

    """

    interval_entries = self.findAll(i.getLeftEndpoint())

    matching_interval_entries = [x for x in interval_entries if x[0].isEqualTo(i)]

    chosen_interval_entry = matching_intervals[0]

    self.remove(IntervalEntry((chosen_interval_entry[0]).getLeftEndpoint(), value))

    """
    
    # for taking care of max values
    
    # tree_search = self._treeSearchWithUntransformedKey

    # print "interval to be removed:", i.toString(), value
    
    # w = self.removeRetrieveNode(IntervalEntry(i, value), tree_search)
    
    w = self._removeRetrieveNode(IntervalEntry(i, value))

    """

    print w.isExternal()

    print self.toString()

    """
    
    rem_node = self._removeRetrieveReplacementNode(w)
    
    rem_node_sibling = rem_node.getSibling()
    
    """

    # actually remove

    self.removeWithUntransformedKey(IntervalEntry(i, value))
    
    """
    
    # actually remove
    
    # entry, node = self._removeWithUntransformedKeyForTree(IntervalEntry(i, value))

    entry, node = self._removeForTree(IntervalEntry(i, value))
    
    # take care of max values
    
    self._updateMaxValuesForParents(rem_node_sibling)
    
    return (entry, node)

    """
    
    # actually remove
    
    entry, node = self._removeForTree(i, value)
    
    # take care of max values
    
    self._updateMaxValuesForParents(node)

    """

  """

  # choose a max-responsible entry

  """

  # return a max value

  def chooseNextMaxValueGivenCandidates(self, candidate_max_bearing_node_options, candidate_specific_node_options):

    result = self._chooseNextMaxValueGivenCandidates(candidate_max_bearing_node_options, candidate_specific_node_options)

    node, max_value, is_max_bearing_node = result

    return max_value

  # retrieve a (tagged_node, max_value) tuple, 
  #   where a tagged node is a tuple of the following form: 
  #   (node, is_max_bearing_node)

  # tagged_candidate_node_option_list is a list 
  #   consisting of tagged candidate node options, 
  #   where each tagged candidate node option 
  #   is a (node_option, is_max_bearing_node) tuple

  # a candidate node can be either of the following two types:
  #   1. a max-bearing node (i.e. we consider its max value) 
  #   2. specific node (i.e. we consider its right endpoint)

  # node is one of the candidates given, 
  #   rather than one associated with actual interval 
  #   whose right endpoint is the source 
  #   of the max value retrieved

  def _chooseFromCandidateNodesHelper(self, tagged_candidate_node_option_list):

    tagged_candidate_max_bearing_node_option_list = [x for x in tagged_candidate_node_option_list if x[1] == True]

    tagged_candidate_specific_node_option_list = [x for x in tagged_candidate_node_option_list if x[1] == False]

    candidate_max_bearing_node_option_list = [x[0] for x in tagged_candidate_max_bearing_node_option_list]

    candidate_specific_node_option_list = [x[0] for x in tagged_candidate_specific_node_option_list]

    candidate_max_bearing_nodes = [x for x in candidate_max_bearing_node_option_list if x != None]

    candidate_specific_nodes = [x for x in candidate_specific_node_option_list if x != None]

    max_bearing_node_possible_max_value_pairs = [(x, self._getMax(x)) for x in candidate_max_bearing_nodes]

    specific_node_possible_max_value_pairs = [(x, x.getKey().getRightEndpoint()) for x in candidate_specific_nodes]

    node_possible_max_value_pairs = max_bearing_node_possible_max_value_pairs + specific_node_possible_max_value_pairs

    """

    candidate_nodes = [x for x in candidate_node_options if x != None]

    """

    # node_possible_max_value_pairs = [(x, x.getMaxValue()) for x in candidate_nodes]

    """

    node_possible_max_value_pairs = [(x, self._getMax(x)) for x in candidate_nodes]

    node_possible_max_value_pairs = [(x[0], (x[1]).getValue()) for x in node_possible_max_endpoint_pairs]

    possible_max_values = [x[1] for x in node_possible_max_value_pairs]

    """

    possible_max_values = [x[1] for x in node_possible_max_value_pairs]

    max_possible_max_value = max(possible_max_values)

    node_possible_max_value_pair_matches = [x for x in node_possible_max_value_pairs if x[1] == max_possible_max_value]

    chosen_node_possible_max_value_pair = node_possible_max_value_pair_matches[0]

    chosen_node = chosen_node_possible_max_value_pair[0]

    is_max_bearing_node = chosen_node in candidate_max_bearing_nodes

    """

    responsible_entry = chosen_node.getElement()

    return responsible_entry

    """

    result = ((chosen_node, is_max_bearing_node), max_possible_max_value)

    return result

  # retrieve a scalar

  def _getMax(self, node):

    """

    endpoint = node.getMaxEndpoint()

    max_value = endpoint.getValue()

    return max_value

    """

    max_value = node.getMaxValue()

    return max_value

  """

  # set a max value based on a responsible entry

  """

  def _setMax(self, node, max_value):

    """

    entry = responsible_entry.getElement()

    node.setMaxEndpoint(MaxIntervalRightEndpoint(entry))

    """

    # node.setMaxEndpoint(MaxIntervalRightEndpoint(entry))

    max_value = None

    if source_node_is_a_max_bearing_node == True:

      max_value = source_node.getMaxValue()

    else:

      max_value = source_node.getElement().getKey().getRightEndpoint()

    node.setMaxValue(max_value)

  def getResponsibleIntervalFromNode(self):

    pass

  def _zig_zig(self, x):

    # take care of max values

    y = x.getParent()

    z = y.getParent()

    if x.isLeftChild() == True:

      # left, left

      t1 = x.getLeftChild()

      t2 = x.getRightChild()

      t3 = y.getRightChild()

      t4 = z.getRightChild()
      
      """
      
      print x, y, z
      
      print t1, t2, t3, t4
      
      """

      """

      z_max_node_option_list = [(t3, True), (t4, True), (z, False)]

      z_tagged_chosen_node, z_max = self._chooseNextMaxValueGivenCandidatesHelper(z_max_node_option_list)

      z_chosen_node, z_chosen_node_is_max_bearing = z_tagged_chosen_node

      y_max_node_option_list = [(t2, True), z_tagged_chosen_node, (y, False)]

      y_tagged_chosen_node, y_max = self._chooseNextMaxValueGivenCandidatesHelper(y_max_node_option_list)

      y_chosen_node, y_chosen_node_is_max_bearing = y_tagged_chosen_node

      x_max_node_option_list = [(t1, True), y_tagged_chosen_node, (x, False)]

      x_tagged_chosen_node, x_max = self._chooseNextMaxValueGivenCandidatesHelper(x_max_node_option_list)

      x_chosen_node, x_chosen_node_is_max_bearing = x_tagged_chosen_node

      self._setMax(x, x_tagged_chosen_node)

      self._setMax(y, y_tagged_chosen_node)

      self._setMax(z, z_tagged_chosen_node)

      """

      """

      z_max_candidates = [getMax(t3), getMax(t4), getRightEndpointUsingNode(z)]
      
      z_max_candidates_winnowed = [c for c in z_max_candidates if c != None]
      
      z_max = max(z_max_candidates_winnowed)
      
      y_max_candidates = [getMax(t2), z_max, getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      x_max_candidates = [getMax(t1), y_max, getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

      z.setMax(z_max)

      """

    else:

      # right, right

      t1 = z.getLeftChild()

      t2 = y.getLeftChild()

      t3 = x.getLeftChild()

      t4 = x.getRightChild()

      z_max_candidate_node_option_list = [t1, t2, z]

      z_max_responsible_entry = self._chooseMaxResponsibleEntry(z_max_candidate_node_option_list)

      z_max_responsible_node = z_max_responsible_entry.getLocation()

      y_max_candidate_node_option_list = [z_max_responsible_node, t3, y]

      y_max_responsible_entry = self._chooseMaxResponsibleEntry(y_max_candidate_node_option_list)

      y_max_responsible_node = y_max_responsible_entry.getLocation()

      x_max_candidate_node_option_list = [y_max_responsible_node, t4, x]

      x_max_responsible_entry = self._chooseMaxResponsibleEntry(x_max_candidate_node_option_list)

      x_max_responsible_node = x_max_responsible_entry.getLocation()

      self._setMax(x_max_responsible_entry)

      self._setMax(y_max_responsible_entry)

      self._setMax(z_max_responsible_entry)
      
      """

      z_max_candidates = [getMax(t1), getMax(t2), getRightEndpointUsingNode(z)]
      
      z_max_candidates_winnowed = [c for c in z_max_candidates if c != None]
      
      z_max = max(z_max_candidates_winnowed)
      
      y_max_candidates = [z_max, getMax(t3), getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      x_max_candidates = [y_max, getMax(t4), getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

      z.setMax(z_max)

      """

    SplayTree._zig_zig(self, x)

  def _zig_zag(self, x):

    # take care of max values

    y = x.getParent()

    z = y.getParent()

    if x.isRightChild() == True:

      # left, right

      t1 = y.getLeftChild()

      t2 = x.getLeftChild()

      t3 = x.getRightChild()

      t4 = z.getRightChild()
      
      z_max_candidate_node_option_list = [t1, t2, y]

      z_max_responsible_entry = self._chooseMaxResponsibleEntry(z_max_candidate_node_option_list)

      z_max_responsible_node = z_max_responsible_entry.getLocation()

      y_max_candidate_node_option_list = [t3, t4, z_max_responsible_node]

      y_max_responsible_entry = self._chooseMaxResponsibleEntry(y_max_candidate_node_option_list)

      y_max_responsible_node = y_max_responsible_entry.getLocation()

      x_max_candidate_node_option_list = [y_max_responsible_node, z_max_responsible_node, x]

      x_max_responsible_entry = self._chooseMaxResponsibleEntry(x_max_candidate_node_option_list)

      x_max_responsible_node = x_max_responsible_entry.getLocation()

      self._setMax(x_max_responsible_entry)

      self._setMax(y_max_responsible_entry)

      self._setMax(z_max_responsible_entry)

      """

      y_max_candidates = [getMax(t1), getMax(t2), getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      z_max_candidates = [getMax(t3), getMax(t4), getRightEndpointUsingNode(z)]
      
      z_max_candidates_winnowed = [c for c in z_max_candidates if c != None]
      
      z_max = max(z_max_candidates_winnowed)
      
      x_max_candidates = [y_max, z_max, getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

      z.setMax(z_max)

      """

    else:

      # right, left

      t1 = z.getLeftChild()

      t2 = x.getLeftChild()

      t3 = x.getRightChild()

      t4 = y.getRightChild()
      
      z_max_candidate_node_option_list = [t1, t2, z]

      z_max_responsible_entry = self._chooseMaxResponsibleEntry(z_max_candidate_node_option_list)

      z_max_responsible_node = z_max_responsible_entry.getLocation()

      y_max_candidate_node_option_list = [t1, t3, y]

      y_max_responsible_entry = self._chooseMaxResponsibleEntry(y_max_candidate_node_option_list)

      y_max_responsible_node = y_max_responsible_entry.getLocation()

      x_max_candidate_node_option_list = [z_max_responsible_node, y_max_responsible_node, x]

      x_max_responsible_entry = self._chooseMaxResponsibleEntry(x_max_candidate_node_option_list)

      x_max_responsible_node = x_max_responsible_entry.getLocation()

      self._setMax(x_max_responsible_entry)

      self._setMax(y_max_responsible_entry)

      self._setMax(z_max_responsible_entry)

      """

      z_max_candidates = [getMax(t1), getMax(t2), getRightEndpointUsingNode(z)]
      
      z_max_candidates_winnowed = [c for c in z_max_candidates if c != None]
      
      z_max = max(z_max_candidates_winnowed)
      
      y_max_candidates = [getMax(t3), getMax(t4), getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      x_max_candidates = [z_max, y_max, getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

      z.setMax(z_max)

      """

    SplayTree._zig_zag(self, x)

  def _zig(self, x):

    # take care of max values

    y = x.getParent()

    w1 = x.getLeftChild()

    w2 = x.getRightChild()

    if x.isLeftChild() == True:

      # left

      t3 = x.getRightChild()

      t4 = y.getRightChild()
      
      y_max_candidate_node_option_list = [t3, t4, y]

      y_max_responsible_entry = self._chooseMaxResponsibleEntry(y_max_candidate_node_option_list)

      y_max_responsible_node = y_max_responsible_entry.getLocation()

      x_max_candidate_node_option_list = [w1, y_max_responsible_node, x]

      x_max_responsible_entry = self._chooseMaxResponsibleEntry(x_max_candidate_node_option_list)

      x_max_responsible_node = x_max_responsible_entry.getLocation()

      self._setMax(x_max_responsible_entry)

      self._setMax(y_max_responsible_entry)

      """

      y_max_candidates = [getMax(t3), getMax(t4), getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      x_max_candidates = [getMax(w1), y_max, getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

      """

    else:

      # right

      t1 = y.getLeftChild()

      t2 = x.getLeftChild()

      y_max_candidate_node_option_list = [t1, t2, y]

      y_max_responsible_entry = self._chooseMaxResponsibleEntry(y_max_candidate_node_option_list)

      y_max_responsible_node = y_max_responsible_entry.getLocation()

      x_max_candidate_node_option_list = [y_max_responsible_node, w2, x]

      x_max_responsible_entry = self._chooseMaxResponsibleEntry(x_max_candidate_node_option_list)

      x_max_responsible_node = x_max_responsible_entry.getLocation()

      self._setMax(x_max_responsible_entry)

      self._setMax(y_max_responsible_entry)

      """

      y_max_candidates = [getMax(t1), getMax(t2), getRightEndpointUsingNode(y)]
      
      y_max_candidates_winnowed = [c for c in y_max_candidates if c != None]
      
      y_max = max(y_max_candidates_winnowed)
      
      x_max_candidates = [y_max, getMax(w2), getRightEndpointUsingNode(x)]
      
      x_max_candidates_winnowed = [c for c in x_max_candidates if c != None]
      
      x_max = max(x_max_candidates_winnowed)

      x.setMax(x_max)

      y.setMax(y_max)

      """

    SplayTree._zig(self, x)

  # retrieve a node corresponding to one overlapped interval, 
  #   with ties between intervals resolved arbitrarily
  
  # interval is an interval object
  
  # return an (entry, node) pair

  # takes O(log(n)) time

  def intervalSearch(self, interval):

    node = self._intervalSearchHelper(interval, None, self.getRoot())

    entry = node.getElement()

    return (entry, node)

  # assume the tree is not empty

  # returns an internal node 
  #   or an external node 
  #   where interval should go

  def _intervalSearchHelper(self, interval, prev_node, curr_node):

    print "interval search - interval:", interval.toString()

    if curr_node.isExternal() == True:

      return prev_node

    else:

      curr_interval = curr_node.getElement().getKey()

      print "interval search - current interval:", curr_interval.toString()

      if curr_interval.overlapsInterval(interval):

        print "interval search - interval overlap:", curr_interval.toString(), interval.toString()

        return curr_node

      # travel in a safe direction

      have_left_child = curr_node.hasLeftChild()

      left_endpoint = interval.getLeftEndpoint()

      if have_left_child == True:

        print "max value:", curr_node.getLeftChild().getMax()

      look_at_left = have_left_child and curr_node.getLeftChild().getMax() >= left_endpoint

      look_at_right = not look_at_left

      if look_at_left == True:

        return self._intervalSearchHelper(interval, curr_node, curr_node.getLeftChild())

      elif look_at_right == True:

        return self._intervalSearchHelper(interval, curr_node, curr_node.getRightChild())

  """

  # retrieve a node corresponding to one overlapped interval, 
  #   with ties between intervals resolved arbitrarily
  
  # i is an interval object
  
  # return an (entry, node) pair

  # if no overlapped interval, return None

  def intervalSearch(self, i):

    node = self._intervalSearch(i)

    print node == None

    if node == None:

      return None

    interval = node.getElement().getKey()

    entry = node.getElement()

    if interval.overlapsInterval(i):

      return (entry, node)

    else:

      return None

  # assume the tree is not empty

  # returns a node

  def _intervalSearch(self, i):

    x = self.getRoot()

    if self.isEmpty() == True:

      raise Exception("tree is empty")
    
    curr_interval = x.getElement().getKey()

    # print x.getElement().toString()

    # print curr_interval

    # print x.getMax()
    
    while x != None and not curr_interval.overlapsInterval(i):

      if x.hasLeftChild() == True \
        and x.getLeftChild().getMax() >= i.getLeftEndpoint():

        x = x.getLeftChild()
      
      else:
      
        x = x.getRightChild()
        
    return x

  """

  """

  def _toString(self, node):

    if node == None:

      # non-existent node

      return "None"

    else:

      left_child_str = self._toString(node.getLeftChild())

      curr_element = node.getElement()

      if curr_element != None:

        curr_entry_str = str(self.getKeyString(node))

      else:

        # non-existent key (possibly because entry does not exist)

        curr_entry_str = "None"

      right_child_str = self._toString(node.getRightChild())

      partial_str = "(" + curr_entry_str + " " + left_child_str + " " + right_child_str + ")"

      return partial_str

  def getKeyString(self, node):

    entry = node.getElement()

    interval = entry.getKey()

    left_endpoint = interval.getLeftEndpoint()

    right_endpoint = interval.getRightEndpoint()

    result_str = "[" + str(left_endpoint) + ", " + str(right_endpoint) + "]"

    return result_str

  """

  def toIntervalList(self):

    internal_node_list = self.toInorderInternalNodeList()

    interval_list = [x.getElement().getKey() for x in internal_node_list]

    return interval_list

  def toIntervalStringList(self):

    interval_list = self.toIntervalList()

    interval_string_list = [x.toString() for x in interval_list]

    return interval_string_list

# node can be non-existent, 
# in which case it would be None; 
# in this case, we return None

def getMax(node):

  if node == None:
  
    return None
    
  else:
  
    return node.getMax()
    
# node can have no entry; 
# in this case, we return None

def getRightEndpointUsingNode(node):

  if node.getElement() == None:
  
    return None
    
  else:
  
    return node.getElement().getKey().getRightEndpoint()

"""

t1 = BalancedIntervalTree.construct([(Interval(0, 1), 1), (Interval(1, 2), 1), (Interval(2, 3), 1)])

# print t1.toString()

print t1.toInorderList()

t1.intervalInsert(Interval(3, 4), 1)

# print t1.toString()

print t1.toInorderList()

t1.intervalDelete(Interval(1, 2), 1)

# print t1.toString()

print t1.toInorderList()

print t1.intervalSearch(Interval(2.5, 2.5))

t2 = BalancedIntervalTree.construct([(Interval(1, 11), 1), (Interval(2, 12), 1), (Interval(4, 14), 1), (Interval(3, 5), 1), (Interval(0, 10), 1)])

print t2.toString()

print t2.toInorderList()

"""

"""

from SweepLineTouchingSlab import *

from LeadingSweepLineTouchingSlab import *

from TrailingSweepLineTouchingSlab import *

from SweepLineTouchingSlabInterval import *

from ..SweepLine import *

t2 = BalancedIntervalTree.construct([(Interval(0, 1), 1), (Interval(1, 2), 1), (Interval(2, 3), 1)])

sweep_line = SweepLine()

sweep_line.setY(3)

slab1 = SweepLineTouchingSlab(3, 4, sweep_line)

slab_interval1 = SweepLineTouchingSlabInterval(slab1)

t2.intervalInsert(slab_interval1, 1)

slab2 = TrailingSweepLineTouchingSlab(4, sweep_line)

slab_interval2 = SweepLineTouchingSlabInterval(slab2)

t2.intervalInsert(slab_interval2, 1)

slab3 = LeadingSweepLineTouchingSlab(0, sweep_line)

slab_interval3 = SweepLineTouchingSlabInterval(slab3)

t2.intervalInsert(slab_interval3, 1)

print t2.toIntervalStringList()

"""

