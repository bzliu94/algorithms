# for purpose of finding monotonic labels

# have a tree built on list nodes

# support finding labels for list nodes in O(1) time

# one approach would be to use 
# an augmented scapegoat tree 
# built on representatives

# the approach that we have taken 
# is to use an augmented scapegoat tree 
# together with a hash table

"""

# heavy lifting

# parity

# prospective path label

# latent/effective key

# latent key: list node

# effective key: path label

# for rebuilds and inserts, 
#   update labels for list nodes

# maintain an invariant - 
#   between operations, 
#   label for each list node 
#   is correct

"""

"""

# update labels for list nodes

"""

from PathLabeledScapegoatTree import *

class LabelTree(PathLabeledScapegoatTree):

  def __init__(self, key_transform = lambda x: x, comparator = comp):

    PathLabeledScapegoatTree.__init__(self, key_transform, comparator)

  # takes O(log(n)) time

  def addBefore(self, v, z):

    # place item as predecessor

    result = DoublyLinkedList.addBefore(self, v, z)

  # takes O(log(n)) time

  def addAfter(self, v, z):

    # place item as successor

    result = DoublyLinkedList.addAfter(self, v, z)

  # takes O(log(n)) time

  def remove(self, v):

    # remove item

    result = DoublyLinkedList.remove(self, v)

  # takes O(log(n)) time

  def addFirst(self, v):

    # place item as overall minimum

    result = DoublyLinkedList.addFirst(self, v)

  # takes O(log(n)) time

  def _getPathLabel(self, v):

    pass

  # takes O(1) time

  def getPathLabel(self, v):

    pass

